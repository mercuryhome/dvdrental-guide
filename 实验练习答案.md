# PostgreSQL 17 SQL 实验练习答案

## 实验一：数据库环境搭建与基础查询

### 练习1：查询演员信息
```sql
-- 查询所有演员的姓名，按姓氏排序
SELECT first_name, last_name
FROM actor
ORDER BY last_name, first_name;

-- 查询演员总数
SELECT COUNT(*) AS "演员总数"
FROM actor;
```

### 练习2：查询电影信息
```sql
-- 查询所有电影的标题和发行年份
SELECT title, release_year
FROM film
ORDER BY release_year DESC, title;

-- 查询电影的平均时长
SELECT AVG(length) AS "平均时长"
FROM film
WHERE length IS NOT NULL;
```

---

## 实验二：数据过滤与排序

### 练习1：条件查询
```sql
-- 查询2006年发行的电影
SELECT title, release_year, rating
FROM film
WHERE release_year = 2006
ORDER BY title;

-- 查询时长在90-120分钟之间的电影
SELECT title, length, rating
FROM film
WHERE length BETWEEN 90 AND 120
ORDER BY length;
```

### 练习2：模糊查询
```sql
-- 查询标题包含"Love"的电影
SELECT title, description
FROM film
WHERE title LIKE '%Love%';

-- 查询以"A"开头的电影
SELECT title, release_year
FROM film
WHERE title LIKE 'A%'
ORDER BY title;
```

---

## 实验三：多表连接查询

### 练习1：基本连接
```sql
-- 查询电影及其语言
SELECT 
    f.title AS "电影标题",
    l.name AS "语言"
FROM film f
INNER JOIN language l ON f.language_id = l.language_id
ORDER BY f.title;

-- 查询演员参演的电影
SELECT 
    a.first_name || ' ' || a.last_name AS "演员姓名",
    f.title AS "电影标题"
FROM actor a
INNER JOIN film_actor fa ON a.actor_id = fa.actor_id
INNER JOIN film f ON fa.film_id = f.film_id
ORDER BY a.last_name, a.first_name, f.title;
```

### 练习2：复杂连接
```sql
-- 查询租赁详细信息
SELECT 
    c.first_name || ' ' || c.last_name AS "客户姓名",
    f.title AS "电影标题",
    r.rental_date AS "租赁日期",
    r.return_date AS "归还日期"
FROM rental r
INNER JOIN customer c ON r.customer_id = c.customer_id
INNER JOIN inventory i ON r.inventory_id = i.inventory_id
INNER JOIN film f ON i.film_id = f.film_id
ORDER BY r.rental_date DESC
LIMIT 20;
```

---

## 实验四：聚合函数与分组查询

### 练习1：基本聚合
```sql
-- 按分类统计电影数量
SELECT 
    c.name AS "分类",
    COUNT(f.film_id) AS "电影数量"
FROM category c
INNER JOIN film_category fc ON c.category_id = fc.category_id
INNER JOIN film f ON fc.film_id = f.film_id
GROUP BY c.category_id, c.name
ORDER BY COUNT(f.film_id) DESC;

-- 按评级统计电影的平均时长
SELECT 
    rating AS "评级",
    COUNT(*) AS "电影数量",
    AVG(length) AS "平均时长"
FROM film
WHERE length IS NOT NULL
GROUP BY rating
ORDER BY AVG(length) DESC;
```

### 练习2：客户消费统计
```sql
-- 统计每个客户的总消费
SELECT 
    c.first_name || ' ' || c.last_name AS "客户姓名",
    COUNT(r.rental_id) AS "租赁次数",
    SUM(p.amount) AS "总消费"
FROM customer c
LEFT JOIN rental r ON c.customer_id = r.customer_id
LEFT JOIN payment p ON r.rental_id = p.rental_id
GROUP BY c.customer_id, c.first_name, c.last_name
HAVING COUNT(r.rental_id) > 0
ORDER BY SUM(p.amount) DESC
LIMIT 10;
```

---

## 实验五：子查询与复杂查询

### 练习1：标量子查询
```sql
-- 查询高于平均租金的电影
SELECT title, rental_rate
FROM film
WHERE rental_rate > (
    SELECT AVG(rental_rate)
    FROM film
)
ORDER BY rental_rate DESC;

-- 查询每个分类中租金最高的电影
SELECT 
    f.title,
    f.rental_rate,
    c.name AS category_name
FROM film f
INNER JOIN film_category fc ON f.film_id = fc.film_id
INNER JOIN category c ON fc.category_id = c.category_id
WHERE f.rental_rate = (
    SELECT MAX(f2.rental_rate)
    FROM film f2
    INNER JOIN film_category fc2 ON f2.film_id = fc2.film_id
    WHERE fc2.category_id = fc.category_id
);
```

### 练习2：EXISTS 查询
```sql
-- 查询有租赁记录的客户
SELECT 
    c.first_name || ' ' || c.last_name AS "客户姓名",
    c.email
FROM customer c
WHERE EXISTS (
    SELECT 1
    FROM rental r
    WHERE r.customer_id = c.customer_id
)
ORDER BY c.last_name, c.first_name;
```

---

## 实验六：数据修改操作

### 练习1：插入数据
```sql
-- 插入新的语言记录
INSERT INTO language (name, last_update)
VALUES ('中文', CURRENT_TIMESTAMP);

-- 插入新的分类
INSERT INTO category (name, last_update)
VALUES ('科幻', CURRENT_TIMESTAMP);
```

### 练习2：更新数据
```sql
-- 更新电影的租金（将PG-13电影的租金提高5%）
UPDATE film
SET rental_rate = rental_rate * 1.05,
    last_update = CURRENT_TIMESTAMP
WHERE rating = 'PG-13';

-- 查看更新结果
SELECT title, rating, rental_rate
FROM film
WHERE rating = 'PG-13'
LIMIT 5;
```

### 练习3：删除数据
```sql
-- 删除测试数据
DELETE FROM language WHERE name = '中文';
DELETE FROM category WHERE name = '科幻';
```

---

## 实验七：视图与索引

### 练习1：创建视图
```sql
-- 创建电影详细信息视图
CREATE OR REPLACE VIEW film_details AS
SELECT 
    f.film_id,
    f.title,
    f.description,
    f.release_year,
    f.length,
    f.rating,
    f.rental_rate,
    l.name AS language_name,
    c.name AS category_name
FROM film f
LEFT JOIN language l ON f.language_id = l.language_id
LEFT JOIN film_category fc ON f.film_id = fc.film_id
LEFT JOIN category c ON fc.category_id = c.category_id;

-- 使用视图查询
SELECT title, language_name, category_name, rating
FROM film_details
WHERE rating = 'PG-13'
LIMIT 10;
```

### 练习2：创建索引
```sql
-- 为电影标题创建索引
CREATE INDEX idx_film_title ON film(title);

-- 为演员姓名创建复合索引
CREATE INDEX idx_actor_name ON actor(first_name, last_name);

-- 为租赁日期创建索引
CREATE INDEX idx_rental_date ON rental(rental_date);
```

---

## 实验八：存储过程与函数

### 练习1：创建函数
```sql
-- 创建计算电影总价值的函数
CREATE OR REPLACE FUNCTION calculate_film_value(
    p_rental_rate NUMERIC,
    p_replacement_cost NUMERIC
) RETURNS NUMERIC AS $$
BEGIN
    RETURN p_rental_rate + p_replacement_cost;
END;
$$ LANGUAGE plpgsql;

-- 使用函数
SELECT 
    title,
    rental_rate,
    replacement_cost,
    calculate_film_value(rental_rate, replacement_cost) AS total_value
FROM film
LIMIT 10;
```

### 练习2：创建存储过程
```sql
-- 创建更新电影租金的存储过程
CREATE OR REPLACE FUNCTION update_film_rental_rate(
    p_film_id INTEGER,
    p_rate_increase NUMERIC
) RETURNS VOID AS $$
BEGIN
    UPDATE film
    SET rental_rate = rental_rate * (1 + p_rate_increase),
        last_update = CURRENT_TIMESTAMP
    WHERE film_id = p_film_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Film with ID % not found', p_film_id;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- 使用存储过程
SELECT update_film_rental_rate(1, 0.1);
```

---

## 综合练习

### 练习1：业务分析查询
```sql
-- 查询最受欢迎的电影分类
SELECT 
    c.name AS "分类",
    COUNT(r.rental_id) AS "租赁次数",
    SUM(p.amount) AS "总收入"
FROM category c
INNER JOIN film_category fc ON c.category_id = fc.category_id
INNER JOIN film f ON fc.film_id = f.film_id
INNER JOIN inventory i ON f.film_id = i.film_id
INNER JOIN rental r ON i.inventory_id = r.inventory_id
INNER JOIN payment p ON r.rental_id = p.rental_id
GROUP BY c.category_id, c.name
ORDER BY COUNT(r.rental_id) DESC
LIMIT 5;
```

### 练习2：客户行为分析
```sql
-- 查询活跃客户（租赁次数超过10次）
SELECT 
    c.first_name || ' ' || c.last_name AS "客户姓名",
    COUNT(r.rental_id) AS "租赁次数",
    SUM(p.amount) AS "总消费",
    AVG(p.amount) AS "平均消费",
    MIN(r.rental_date) AS "首次租赁",
    MAX(r.rental_date) AS "最近租赁"
FROM customer c
INNER JOIN rental r ON c.customer_id = r.customer_id
INNER JOIN payment p ON r.rental_id = p.rental_id
GROUP BY c.customer_id, c.first_name, c.last_name
HAVING COUNT(r.rental_id) > 10
ORDER BY COUNT(r.rental_id) DESC;
```

### 练习3：库存管理查询
```sql
-- 查询库存状态
SELECT 
    f.title AS "电影标题",
    s.store_id AS "店铺ID",
    COUNT(i.inventory_id) AS "库存数量",
    COUNT(r.rental_id) AS "租赁次数",
    COUNT(i.inventory_id) - COUNT(r.rental_id) AS "可用库存"
FROM film f
INNER JOIN inventory i ON f.film_id = i.film_id
INNER JOIN store s ON i.store_id = s.store_id
LEFT JOIN rental r ON i.inventory_id = r.inventory_id AND r.return_date IS NULL
GROUP BY f.film_id, f.title, s.store_id
ORDER BY f.title, s.store_id;
```

---

## 高级练习

### 练习1：窗口函数
```sql
-- 使用窗口函数计算排名
SELECT 
    title,
    rental_rate,
    ROW_NUMBER() OVER (ORDER BY rental_rate DESC) AS "租金排名",
    RANK() OVER (ORDER BY rental_rate DESC) AS "租金等级",
    DENSE_RANK() OVER (ORDER BY rental_rate DESC) AS "密集排名"
FROM film
ORDER BY rental_rate DESC
LIMIT 10;
```

### 练习2：递归查询
```sql
-- 查询客户租赁历史（按时间顺序）
WITH RECURSIVE rental_history AS (
    -- 基础查询：获取每个客户的首次租赁
    SELECT 
        c.customer_id,
        c.first_name || ' ' || c.last_name AS customer_name,
        r.rental_date,
        1 AS rental_sequence
    FROM customer c
    INNER JOIN rental r ON c.customer_id = r.customer_id
    WHERE r.rental_date = (
        SELECT MIN(r2.rental_date)
        FROM rental r2
        WHERE r2.customer_id = c.customer_id
    )
    
    UNION ALL
    
    -- 递归查询：获取后续租赁
    SELECT 
        rh.customer_id,
        rh.customer_name,
        r.rental_date,
        rh.rental_sequence + 1
    FROM rental_history rh
    INNER JOIN rental r ON rh.customer_id = r.customer_id
    WHERE r.rental_date > rh.rental_date
    AND r.rental_date = (
        SELECT MIN(r2.rental_date)
        FROM rental r2
        WHERE r2.customer_id = rh.customer_id
        AND r2.rental_date > rh.rental_date
    )
)
SELECT customer_name, rental_date, rental_sequence
FROM rental_history
WHERE customer_id = 1
ORDER BY rental_sequence;
```

---

## 性能优化练习

### 练习1：查询优化
```sql
-- 优化前：使用子查询
SELECT title
FROM film
WHERE film_id IN (
    SELECT film_id
    FROM film_category
    WHERE category_id = (
        SELECT category_id
        FROM category
        WHERE name = 'Action'
    )
);

-- 优化后：使用连接
SELECT f.title
FROM film f
INNER JOIN film_category fc ON f.film_id = fc.film_id
INNER JOIN category c ON fc.category_id = c.category_id
WHERE c.name = 'Action';
```

### 练习2：索引优化
```sql
-- 分析查询性能
EXPLAIN ANALYZE
SELECT title, rating, rental_rate
FROM film
WHERE rating = 'PG-13' AND rental_rate > 3.0;

-- 创建复合索引
CREATE INDEX idx_film_rating_rental ON film(rating, rental_rate);

-- 再次分析性能
EXPLAIN ANALYZE
SELECT title, rating, rental_rate
FROM film
WHERE rating = 'PG-13' AND rental_rate > 3.0;
```

---

## 总结

这些练习答案涵盖了：

1. **基础查询**：SELECT、WHERE、ORDER BY
2. **连接查询**：INNER JOIN、LEFT JOIN
3. **聚合查询**：GROUP BY、HAVING、聚合函数
4. **子查询**：标量子查询、EXISTS
5. **数据修改**：INSERT、UPDATE、DELETE
6. **视图和索引**：创建和使用
7. **存储过程**：函数和过程
8. **高级特性**：窗口函数、递归查询
9. **性能优化**：查询优化、索引优化

通过完成这些练习，学生可以：
- 掌握 PostgreSQL 17 的核心功能
- 理解 SQL 查询的优化方法
- 学会解决实际的数据库问题
- 为后续的数据库开发打下坚实基础

---

*建议学生先独立完成练习，再对照答案检查，这样能更好地掌握知识点。*
